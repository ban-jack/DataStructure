### LeetCode 算法题 

#### brackets ======= 处理括号
    
- GenerateBrackets ---> 递归生成括号

- ValidBracketDemo ---> 堆栈处理括号
    
#### linkedlist ======= 链表
    
- ListNode ---> 已经定义的单链表

- mergeTwoListsDemo ---> 合并两个有序链表

- RemoveNodeDemo ---> 删除链表的第n个节点

- SwapNodeDemo ---> 两两交换链表中的节点

- reserveListDemo ---> 反转链表
    
####  recursion ======= 回溯递归算法
    
- FibonacciDemo ---> 斐波那契数列的变形和递归等方法

- letterCombinationsDemo --> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回

- timeRequiredToBuyDemo --> 排队买票时间
 
#### fastslowpoint ==== 快慢指针

- removeDuplicatesDemo ---> 快慢指针删除有序数组的重复项

- removeElementDemo ---> 在数组中移除给定值并返回数组的新长度 
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组

- ThreeSumDemo ---> 给定数组 nums，求出其中存在 三个元素相加等于0 且不重复的三元组。

- threeSumClosestDemo ---> 给定数组 和 目标值 target。
从数组中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。

- FourSumDemo ---> 给定数组 nums，求出其中存在 四个元素相加等于target 且不重复的三元组

- searchInsertPositionDemo ---> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。

- nextArrangeDemo ---> 算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须 原地 修改，只允许使用额外常数空间。

#### scan =========== 扫描法

- onescanDemo ---> 单次扫描法 返回中毒的总时间

#### kmp ============ 字符串匹配算法

- indexOfDemo ---> 实现indexof方法 
给定两个字符串，找出 字符串1 中 字符串2 出现的第一个位置（下标从 0 开始）

- detectCapitalUseDemo ---> 检测大写字母

















    
    