### LeetCode 算法题 

#### brackets ======= 处理括号
    
- GenerateBrackets ---> 递归生成括号

- ValidBracketDemo ---> 堆栈处理括号
    
#### linkedlist ======= 链表
    
- ListNode ---> 已经定义的单链表

- mergeTwoListsDemo ---> 合并两个有序链表

- RemoveNodeDemo ---> 删除链表的第n个节点

- SwapNodeDemo ---> 两两交换链表中的节点

- reserveListDemo ---> 反转链表
    
####  recursion ======= 回溯递归算法
    
- FibonacciDemo ---> 斐波那契数列的变形和递归等方法

- letterCombinationsDemo --> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回

- timeRequiredToBuyDemo --> 排队买票时间

- CountDemo --> 给定一个正整数 n ，输出外观数列的第 n 项。
 
#### fastslowpoint ==== 快慢指针

- removeDuplicatesDemo ---> 快慢指针删除有序数组的重复项

- removeElementDemo ---> 在数组中移除给定值并返回数组的新长度 
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组

- ThreeSumDemo ---> 给定数组 nums，求出其中存在 三个元素相加等于0 且不重复的三元组。

- threeSumClosestDemo ---> 给定数组 和 目标值 target。
从数组中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。

- FourSumDemo ---> 给定数组 nums，求出其中存在 四个元素相加等于target 且不重复的三元组

#### scan =========== 扫描法

- onescanDemo ---> 单次扫描法 返回中毒的总时间
- nextArrangeDemo ---> 两次扫描 算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。
  如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须 原地 修改，只允许使用额外常数空间。
- 

#### kmp ============ 字符串匹配算法

- indexOfDemo ---> 实现indexof方法 
给定两个字符串，找出 字符串1 中 字符串2 出现的第一个位置（下标从 0 开始）

- detectCapitalUseDemo ---> 检测大写字母


#### search ============ 搜索算法

- searchInsertPositionDemo ---> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 O(log n) 的算法。

- rotatedSortedArrayDemo --> 整数数组 nums 按升序排列，数组中的值互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，
例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
使用时间复杂度为 O(log n) 的算法.

- findElementInArrayDemo --> 在给定一个按照升序排列的整数数组 nums 中查找目标值 target 的第一个和最后一个位置 
如果数组中不存在目标值 返回 [-1, -1]。



    
    